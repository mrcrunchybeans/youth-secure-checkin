#!/usr/bin/env python3
"""
Comprehensive Security Pentest for checkin.traillifewi4603.org
Tests for common vulnerabilities and security weaknesses
"""

import requests
import json
import time
import re
from datetime import datetime
from urllib.parse import urljoin, urlparse
import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

# Configuration
TARGET_URL = "https://checkin.traillifewi4603.org"
TIMEOUT = 10

class PentestResults:
    def __init__(self):
        self.results = []
        self.critical = []
        self.warnings = []
        self.passed = []
        
    def add_critical(self, title, description, evidence=""):
        self.critical.append({"title": title, "description": description, "evidence": evidence})
        self.results.append(f"‚ùå CRITICAL: {title}")
        
    def add_warning(self, title, description, evidence=""):
        self.warnings.append({"title": title, "description": description, "evidence": evidence})
        self.results.append(f"‚ö†Ô∏è  WARNING: {title}")
        
    def add_pass(self, title, description=""):
        self.passed.append({"title": title, "description": description})
        self.results.append(f"‚úÖ PASS: {title}")
        
    def print_summary(self):
        print("\n" + "="*60)
        print("PENTEST SUMMARY")
        print("="*60)
        for result in self.results:
            print(result)
        print("="*60)
        print(f"Critical Issues: {len(self.critical)}")
        print(f"Warnings: {len(self.warnings)}")
        print(f"Passed Tests: {len(self.passed)}")
        print("="*60)
        
    def detailed_report(self):
        print("\n\n" + "="*60)
        print("DETAILED FINDINGS")
        print("="*60)
        
        if self.critical:
            print("\nüî¥ CRITICAL VULNERABILITIES:")
            for item in self.critical:
                print(f"\n  Title: {item['title']}")
                print(f"  Description: {item['description']}")
                if item['evidence']:
                    print(f"  Evidence: {item['evidence']}")
                    
        if self.warnings:
            print("\nüü° WARNINGS:")
            for item in self.warnings:
                print(f"\n  Title: {item['title']}")
                print(f"  Description: {item['description']}")
                if item['evidence']:
                    print(f"  Evidence: {item['evidence']}")
                    
        if self.passed:
            print("\nüü¢ SECURITY CHECKS PASSED:")
            for item in self.passed:
                print(f"\n  ‚úì {item['title']}")
                if item['description']:
                    print(f"    {item['description']}")

def test_connectivity():
    """Test basic connectivity to the target"""
    print("\n[*] Testing connectivity...")
    try:
        response = requests.head(TARGET_URL, timeout=TIMEOUT, verify=False, allow_redirects=True)
        return True
    except Exception as e:
        print(f"‚ùå Cannot reach target: {e}")
        return False

def test_ssl_certificate(results):
    """Test SSL certificate validity"""
    print("[*] Testing SSL certificate...")
    try:
        requests.get(TARGET_URL, timeout=TIMEOUT, verify=True)
        results.add_pass("SSL Certificate", "Valid SSL certificate")
    except requests.exceptions.SSLError as e:
        if "certificate verify failed" in str(e):
            results.add_critical("SSL Certificate", "Invalid or self-signed certificate", str(e))
        else:
            results.add_warning("SSL Certificate", "SSL error detected", str(e))
    except Exception as e:
        results.add_warning("SSL Certificate", "Could not verify SSL", str(e))

def test_security_headers(results):
    """Test for security headers"""
    print("[*] Testing security headers...")
    try:
        response = requests.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        headers = response.headers
        
        # Check for important security headers
        security_headers = {
            'Strict-Transport-Security': 'HSTS',
            'X-Content-Type-Options': 'Content-Type sniffing prevention',
            'X-Frame-Options': 'Clickjacking prevention',
            'Content-Security-Policy': 'CSP',
            'X-XSS-Protection': 'XSS protection'
        }
        
        for header, description in security_headers.items():
            if header in headers:
                results.add_pass(f"Security Header: {header}", description)
            else:
                results.add_warning(f"Missing Security Header: {header}", f"Missing {description} header")
                
    except Exception as e:
        results.add_warning("Security Headers", "Could not test headers", str(e))

def test_login_interface(results):
    """Test login interface for vulnerabilities"""
    print("[*] Testing login interface...")
    try:
        response = requests.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        
        if "login" in response.text.lower():
            # Check for basic HTML validation
            if "password" in response.text.lower():
                results.add_pass("Login Interface Detected", "Login form found")
                
                # Check for autocomplete on password field
                if 'autocomplete="off"' in response.text:
                    results.add_pass("Password Autocomplete", "Disabled on password fields")
                else:
                    results.add_warning("Password Autocomplete", "May allow browser to remember password", 
                                      "Check HTML for autocomplete=off on password fields")
        else:
            results.add_warning("Login Interface", "No login form detected on homepage")
            
    except Exception as e:
        results.add_warning("Login Interface", "Could not test", str(e))

def test_brute_force_protection(results):
    """Test for brute force protection"""
    print("[*] Testing brute force protection...")
    
    # First, find the login endpoint
    try:
        response = requests.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        
        # Try multiple failed logins rapidly
        session = requests.Session()
        failed_attempts = 0
        locked = False
        
        for i in range(10):
            try:
                # Try to submit login with wrong credentials
                data = {
                    'password': f'wrongpass{i}',
                }
                
                # Try common login endpoints
                for endpoint in ['/login', '/admin/login', '/', '/checkin']:
                    try:
                        r = session.post(
                            urljoin(TARGET_URL, endpoint),
                            data=data,
                            timeout=TIMEOUT,
                            verify=False,
                            allow_redirects=False
                        )
                        
                        # Check for rate limiting indicators
                        if r.status_code == 429:  # Too Many Requests
                            locked = True
                            break
                        if "too many attempts" in r.text.lower():
                            locked = True
                            break
                        if "locked" in r.text.lower():
                            locked = True
                            break
                            
                        failed_attempts += 1
                    except:
                        pass
                        
                if locked:
                    break
                    
            except Exception as e:
                pass
        
        if locked:
            results.add_pass("Brute Force Protection", "Rate limiting detected after multiple failed attempts")
        elif failed_attempts >= 5:
            results.add_critical("Brute Force Protection", 
                               "No rate limiting detected - multiple failed logins allowed",
                               f"Successfully attempted {failed_attempts} failed logins without lockout")
        else:
            results.add_warning("Brute Force Protection", "Could not determine if protection is active", 
                              f"Only {failed_attempts} attempts could be made")
            
    except Exception as e:
        results.add_warning("Brute Force Protection", "Could not test", str(e))

def test_password_strength_requirements(results):
    """Test for password strength enforcement"""
    print("[*] Testing password strength requirements...")
    
    try:
        # Look for password strength indicators in the page
        response = requests.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        
        if "password" in response.text.lower():
            # Check for password requirements in HTML comments or JavaScript
            if any(x in response.text for x in ["uppercase", "lowercase", "number", "special", "12"]):
                results.add_pass("Password Requirements", "Password strength requirements appear to be enforced")
            elif "strength" in response.text.lower():
                results.add_pass("Password Validation", "Password validation detected")
            else:
                results.add_warning("Password Requirements", 
                                   "Could not verify password strength requirements",
                                   "Check if minimum length and character requirements are enforced")
        else:
            results.add_warning("Password Requirements", "No login form found")
            
    except Exception as e:
        results.add_warning("Password Requirements", "Could not test", str(e))

def test_session_security(results):
    """Test session handling security"""
    print("[*] Testing session security...")
    
    try:
        session = requests.Session()
        response = session.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        
        # Check for security cookie flags
        if 'Set-Cookie' in response.headers:
            cookie_headers = response.headers.getlist('Set-Cookie') if hasattr(response.headers, 'getlist') else [response.headers.get('Set-Cookie')]
            
            for cookie in cookie_headers:
                if 'Secure' in cookie:
                    results.add_pass("Secure Cookies", "Cookies marked Secure (HTTPS only)")
                else:
                    results.add_warning("Secure Cookies", "Cookies may be transmitted over HTTP")
                    
                if 'HttpOnly' in cookie:
                    results.add_pass("HttpOnly Cookies", "Cookies protected from JavaScript access")
                else:
                    results.add_warning("HttpOnly Cookies", "Cookies may be accessible to JavaScript (XSS risk)")
                    
                if 'SameSite' in cookie:
                    results.add_pass("SameSite Cookies", "CSRF protection via SameSite attribute")
                else:
                    results.add_warning("SameSite Cookies", "Missing SameSite attribute for CSRF protection")
        else:
            results.add_warning("Session Cookies", "No cookies detected in initial response")
            
    except Exception as e:
        results.add_warning("Session Security", "Could not test", str(e))

def test_sql_injection(results):
    """Test for SQL injection vulnerabilities"""
    print("[*] Testing for SQL injection...")
    
    sql_payloads = [
        "' OR '1'='1",
        "' OR 1=1 --",
        "admin' --",
        "' UNION SELECT NULL --"
    ]
    
    test_endpoints = ['/search', '/api/search', '/checkin']
    vulnerable = False
    
    try:
        for endpoint in test_endpoints:
            for payload in sql_payloads:
                try:
                    response = requests.get(
                        urljoin(TARGET_URL, endpoint),
                        params={'q': payload, 'name': payload},
                        timeout=TIMEOUT,
                        verify=False
                    )
                    
                    # Look for SQL error messages
                    if any(x in response.text.lower() for x in ['syntax error', 'sql', 'database error']):
                        vulnerable = True
                        results.add_critical("SQL Injection", 
                                           f"Potential SQL injection on {endpoint}",
                                           f"Payload: {payload}")
                        break
                except:
                    pass
                    
            if vulnerable:
                break
                
        if not vulnerable:
            results.add_pass("SQL Injection", "No obvious SQL injection vulnerabilities detected")
            
    except Exception as e:
        results.add_warning("SQL Injection", "Could not test", str(e))

def test_xss_vulnerabilities(results):
    """Test for XSS vulnerabilities"""
    print("[*] Testing for XSS vulnerabilities...")
    
    xss_payloads = [
        '<script>alert("xss")</script>',
        '"><script>alert("xss")</script>',
        "';alert('xss');//"
    ]
    
    test_endpoints = ['/search', '/api/search', '/checkin']
    vulnerable = False
    
    try:
        for endpoint in test_endpoints:
            for payload in xss_payloads:
                try:
                    response = requests.get(
                        urljoin(TARGET_URL, endpoint),
                        params={'q': payload, 'name': payload},
                        timeout=TIMEOUT,
                        verify=False
                    )
                    
                    # Check if payload is reflected unescaped
                    if payload in response.text and '<script>' in response.text:
                        vulnerable = True
                        results.add_critical("XSS Vulnerability", 
                                           f"Potential XSS on {endpoint}",
                                           f"Payload reflected: {payload}")
                        break
                except:
                    pass
                    
            if vulnerable:
                break
                
        if not vulnerable:
            results.add_pass("XSS Protection", "No obvious XSS vulnerabilities detected")
            
    except Exception as e:
        results.add_warning("XSS Testing", "Could not test", str(e))

def test_csrf_protection(results):
    """Test for CSRF protection"""
    print("[*] Testing CSRF protection...")
    
    try:
        response = requests.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        
        # Look for CSRF tokens in forms
        if 'csrf' in response.text.lower():
            results.add_pass("CSRF Protection", "CSRF tokens appear to be implemented")
        elif 'token' in response.text.lower():
            results.add_pass("CSRF Protection", "Token-based protection detected")
        else:
            results.add_warning("CSRF Protection", 
                               "Could not verify CSRF token implementation",
                               "Forms may be vulnerable to cross-site request forgery")
                               
    except Exception as e:
        results.add_warning("CSRF Protection", "Could not test", str(e))

def test_information_disclosure(results):
    """Test for information disclosure"""
    print("[*] Testing for information disclosure...")
    
    try:
        response = requests.get(TARGET_URL, timeout=TIMEOUT, verify=False)
        
        # Check for version disclosure
        dangerous_patterns = [
            r'Flask/[\d.]+',
            r'Django/[\d.]+',
            r'PHP/[\d.]+',
            r'Apache/[\d.]+',
            r'nginx/[\d.]+',
        ]
        
        server_header = response.headers.get('Server', '').lower()
        
        if server_header:
            # Check if it's too verbose
            if len(server_header) > 20:
                results.add_warning("Server Information Disclosure", 
                                   "Server header reveals detailed version information",
                                   f"Server: {server_header}")
            else:
                results.add_pass("Server Information", "Server header is minimal")
        else:
            results.add_pass("Server Information", "Server header is not disclosed")
            
        # Check for debug mode
        if 'debug' in response.text.lower() or 'traceback' in response.text.lower():
            results.add_warning("Debug Mode", "Application may be running in debug mode")
            
    except Exception as e:
        results.add_warning("Information Disclosure", "Could not test", str(e))

def test_https_redirect(results):
    """Test for HTTP to HTTPS redirect"""
    print("[*] Testing HTTPS redirect...")
    
    try:
        http_url = TARGET_URL.replace('https://', 'http://')
        response = requests.get(http_url, timeout=TIMEOUT, verify=False, allow_redirects=False)
        
        if response.status_code in [301, 302, 303, 307, 308]:
            if 'https' in response.headers.get('Location', '').lower():
                results.add_pass("HTTPS Redirect", "HTTP traffic redirected to HTTPS")
            else:
                results.add_warning("HTTPS Redirect", "Redirect detected but not to HTTPS", 
                                  f"Location: {response.headers.get('Location')}")
        elif response.status_code == 200:
            results.add_critical("HTTPS Not Enforced", 
                               "HTTP requests not redirected to HTTPS",
                               "Site is accessible over unencrypted HTTP")
                               
    except Exception as e:
        # Expected if HTTP is blocked
        results.add_pass("HTTPS Enforcement", "HTTP connections appear to be blocked (expected)")

def test_default_credentials(results):
    """Test for default credentials"""
    print("[*] Testing for default credentials...")
    
    common_defaults = [
        ('admin', 'admin'),
        ('admin', 'password'),
        ('admin', '123456'),
        ('demo', 'demo'),
        ('demo', 'demo123'),
    ]
    
    try:
        session = requests.Session()
        
        for username, password in common_defaults:
            # Try common login endpoints
            for endpoint in ['/login', '/admin/login', '/']:
                try:
                    # First get the page to check for form
                    r = session.get(urljoin(TARGET_URL, endpoint), timeout=TIMEOUT, verify=False)
                    
                    if 'password' in r.text.lower():
                        # Try POST
                        data = {
                            'username': username,
                            'password': password,
                        }
                        
                        r = session.post(
                            urljoin(TARGET_URL, endpoint),
                            data=data,
                            timeout=TIMEOUT,
                            verify=False,
                            allow_redirects=False
                        )
                        
                        # Check if login succeeded
                        if r.status_code in [200, 302, 303] and 'dashboard' in r.text.lower():
                            results.add_critical("Default Credentials", 
                                               f"Default credentials work: {username}/{password}",
                                               f"Endpoint: {endpoint}")
                            return
                except:
                    pass
                    
        results.add_pass("Default Credentials", "Common default credentials do not work")
        
    except Exception as e:
        results.add_warning("Default Credentials", "Could not test", str(e))

def main():
    print("="*60)
    print(f"PENTEST: {TARGET_URL}")
    print(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*60)
    
    results = PentestResults()
    
    # Test connectivity first
    if not test_connectivity():
        print("\n‚ùå Target is not reachable. Aborting pentest.")
        return
    
    # Run all security tests
    test_ssl_certificate(results)
    test_security_headers(results)
    test_login_interface(results)
    test_brute_force_protection(results)
    test_password_strength_requirements(results)
    test_session_security(results)
    test_sql_injection(results)
    test_xss_vulnerabilities(results)
    test_csrf_protection(results)
    test_information_disclosure(results)
    test_https_redirect(results)
    test_default_credentials(results)
    
    # Print results
    results.print_summary()
    results.detailed_report()
    
    print("\n" + "="*60)
    print(f"Completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*60)

if __name__ == "__main__":
    main()
