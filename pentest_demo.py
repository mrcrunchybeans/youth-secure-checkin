#!/usr/bin/env python3
"""
Pentest Script for Youth Secure Check-in Demo Server
Tests for common vulnerabilities and data exposure risks
"""

import requests
import json
import sys
from urllib.parse import urljoin
import time

# Configuration
BASE_URL = "http://demo.youthcheckin.net"
DEFAULT_PASSWORD = "demo123"

class DemoServerPentest:
    def __init__(self, base_url):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.results = []
        self.auth_token = None
        
    def log(self, level, message):
        """Log results"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
        self.results.append((level, message))
    
    def test_connectivity(self):
        """Test if server is reachable"""
        self.log("INFO", "Testing server connectivity...")
        try:
            resp = requests.get(urljoin(self.base_url, "/health"), timeout=5)
            if resp.status_code == 200:
                self.log("PASS", "Server is reachable")
                return True
            else:
                self.log("FAIL", f"Health check failed: {resp.status_code}")
                return False
        except Exception as e:
            self.log("FAIL", f"Cannot reach server: {e}")
            return False
    
    def test_default_credentials(self):
        """Test if default password works"""
        self.log("INFO", "Testing default credentials...")
        try:
            resp = self.session.post(
                urljoin(self.base_url, "/login"),
                data={"password": DEFAULT_PASSWORD},
                allow_redirects=False
            )
            
            if resp.status_code == 302 or "admin" in resp.text.lower():
                self.log("CRITICAL", f"Default password works! Status: {resp.status_code}")
                # Extract session info
                if 'Set-Cookie' in resp.headers:
                    self.log("CRITICAL", f"Session set: {resp.headers['Set-Cookie'][:50]}...")
                return True
            else:
                self.log("PASS", "Default password rejected")
                return False
        except Exception as e:
            self.log("ERROR", f"Login test failed: {e}")
            return False
    
    def test_unauthenticated_access(self):
        """Test if endpoints are accessible without auth"""
        self.log("INFO", "Testing unauthenticated endpoint access...")
        
        endpoints = [
            "/",
            "/admin",
            "/admin/families",
            "/api/families",
            "/search_name",
            "/search_phone"
        ]
        
        for endpoint in endpoints:
            try:
                resp = requests.get(urljoin(self.base_url, endpoint), timeout=5, allow_redirects=False)
                
                # If we get 200, data might be leaked
                if resp.status_code == 200:
                    self.log("CRITICAL", f"Endpoint {endpoint} accessible without auth: {resp.status_code}")
                    
                    # Check for data in response
                    if any(name in resp.text.lower() for name in ["john", "smith", "emma", "noah"]):
                        self.log("CRITICAL", f"PII found in {endpoint} response!")
                
                elif resp.status_code == 302:
                    self.log("PASS", f"Endpoint {endpoint} redirects (likely requires auth): {resp.status_code}")
                else:
                    self.log("INFO", f"Endpoint {endpoint}: {resp.status_code}")
                    
            except Exception as e:
                self.log("ERROR", f"Could not test {endpoint}: {e}")
    
    def test_sql_injection_search(self):
        """Test search endpoints for SQL injection"""
        self.log("INFO", "Testing search endpoints for SQL injection...")
        
        payloads = [
            "' OR '1'='1",
            "' UNION SELECT * FROM adults--",
            "'; DROP TABLE kids;--",
            "' OR 1=1--",
            "admin' --",
            "' OR ''='",
        ]
        
        endpoints = [
            ("/search_name", "name"),
            ("/search_phone", "phone"),
        ]
        
        for endpoint, param in endpoints:
            for payload in payloads:
                try:
                    resp = self.session.post(
                        urljoin(self.base_url, endpoint),
                        data={param: payload},
                        timeout=5
                    )
                    
                    # SQL errors might indicate vulnerability
                    if any(error in resp.text.lower() for error in 
                           ["syntax error", "database", "sql", "table", "column", "query"]):
                        self.log("CRITICAL", f"Possible SQL injection in {endpoint} with payload: {payload}")
                        self.log("CRITICAL", f"Error in response: {resp.text[:200]}")
                    
                    # Check if we got results from malicious query
                    if payload.startswith("'"):
                        if "john" in resp.text.lower() or "smith" in resp.text.lower():
                            self.log("CRITICAL", f"SQL injection may have worked in {endpoint}")
                            
                except Exception as e:
                    self.log("ERROR", f"Could not test SQL injection on {endpoint}: {e}")
    
    def test_response_data_exposure(self):
        """Check if PII is exposed in responses"""
        self.log("INFO", "Testing for PII exposure in responses...")
        
        try:
            # Try to login first
            resp = self.session.post(
                urljoin(self.base_url, "/login"),
                data={"password": DEFAULT_PASSWORD}
            )
            
            # Try to access admin/families
            resp = self.session.get(urljoin(self.base_url, "/admin/families"))
            
            if resp.status_code == 200:
                # Check what data is in the response
                pii_indicators = {
                    "phone": ["555-", "(", ")", "-"],
                    "names": ["Sarah", "Mike", "Emma", "Noah", "Jennifer", "David", "Lisa"],
                    "encrypted": ["gAAAAAB"],
                    "hashes": ["sha256", "pbkdf2"]
                }
                
                for pii_type, indicators in pii_indicators.items():
                    for indicator in indicators:
                        if indicator in resp.text:
                            if pii_type == "names":
                                self.log("CRITICAL", f"Found potential PII ({pii_type}): {indicator}")
                            elif pii_type == "phone":
                                self.log("WARNING", f"Found phone number pattern in response")
                            elif pii_type == "encrypted":
                                self.log("PASS", f"Data appears encrypted (Fernet format)")
                
        except Exception as e:
            self.log("ERROR", f"Could not test response exposure: {e}")
    
    def test_path_traversal(self):
        """Test for path traversal vulnerabilities"""
        self.log("INFO", "Testing for path traversal vulnerabilities...")
        
        payloads = [
            "../../../etc/passwd",
            "../../data/checkin.db",
            "..\\..\\..\\windows\\win.ini",
            "....//....//etc/passwd",
        ]
        
        for payload in payloads:
            try:
                # Try various endpoints
                for endpoint in ["/admin/families/", "/api/", "/static/"]:
                    resp = requests.get(
                        urljoin(self.base_url, endpoint + payload),
                        timeout=5
                    )
                    
                    if resp.status_code == 200 and len(resp.text) > 10:
                        if "root:" in resp.text or "[boot]" in resp.text:
                            self.log("CRITICAL", f"Path traversal vulnerability found: {payload}")
                            self.log("CRITICAL", f"Retrieved system file via {endpoint}")
                        
            except Exception as e:
                pass  # Expected to fail
    
    def test_api_enumeration(self):
        """Try to enumerate all families/kids via API"""
        self.log("INFO", "Testing API enumeration...")
        
        try:
            # Try common API endpoints
            endpoints = [
                "/api/families",
                "/api/kids",
                "/api/adults",
                "/api/events",
                "/families.json",
                "/api/v1/families",
            ]
            
            for endpoint in endpoints:
                resp = requests.get(urljoin(self.base_url, endpoint), timeout=5)
                
                if resp.status_code == 200:
                    self.log("CRITICAL", f"Unauthenticated API access: {endpoint}")
                    try:
                        data = resp.json()
                        if isinstance(data, list) and len(data) > 0:
                            self.log("CRITICAL", f"Enumerated {len(data)} records from {endpoint}")
                            if "name" in str(data[0]).lower():
                                self.log("CRITICAL", f"Names found in unauthenticated API: {endpoint}")
                    except:
                        pass
                        
        except Exception as e:
            self.log("ERROR", f"API enumeration failed: {e}")
    
    def test_session_security(self):
        """Test session and cookie security"""
        self.log("INFO", "Testing session and cookie security...")
        
        try:
            resp = self.session.get(urljoin(self.base_url, "/"))
            
            if 'Set-Cookie' in resp.headers:
                cookies = resp.headers['Set-Cookie']
                
                # Check for security flags
                security_checks = {
                    "Secure": "PASS" if "Secure" in cookies else "WARNING",
                    "HttpOnly": "PASS" if "HttpOnly" in cookies else "WARNING",
                    "SameSite": "PASS" if "SameSite" in cookies else "WARNING",
                }
                
                for flag, result in security_checks.items():
                    self.log(result, f"Cookie flag {flag}: {result}")
            else:
                self.log("INFO", "No Set-Cookie headers found")
                
        except Exception as e:
            self.log("ERROR", f"Could not test session security: {e}")
    
    def test_debug_info_exposure(self):
        """Check for debug/error information exposure"""
        self.log("INFO", "Testing for debug info exposure...")
        
        try:
            # Try invalid requests to trigger errors
            test_urls = [
                "/invalid_endpoint",
                "/admin/families/999999",
                "/api/families/invalid",
            ]
            
            for url in test_urls:
                resp = requests.get(urljoin(self.base_url, url), timeout=5)
                
                # Check for stack traces or debug info
                debug_indicators = [
                    "Traceback",
                    "Flask",
                    "line",
                    "File",
                    "Error",
                    "Exception",
                    "environ"
                ]
                
                for indicator in debug_indicators:
                    if indicator in resp.text:
                        self.log("WARNING", f"Debug info exposed in {url}: {indicator}")
                        
        except Exception as e:
            self.log("ERROR", f"Debug info test failed: {e}")
    
    def run_all_tests(self):
        """Run all pentest checks"""
        self.log("INFO", "=" * 60)
        self.log("INFO", "Starting Pentest for Youth Secure Check-in Demo")
        self.log("INFO", f"Target: {self.base_url}")
        self.log("INFO", "=" * 60)
        
        if not self.test_connectivity():
            self.log("ERROR", "Cannot reach server. Aborting tests.")
            return
        
        # Run all tests
        self.test_default_credentials()
        self.test_unauthenticated_access()
        self.test_sql_injection_search()
        self.test_response_data_exposure()
        self.test_path_traversal()
        self.test_api_enumeration()
        self.test_session_security()
        self.test_debug_info_exposure()
        
        self.log("INFO", "=" * 60)
        self.log("INFO", "Pentest Complete")
        self.log("INFO", "=" * 60)
        
        # Summary
        critical = sum(1 for level, _ in self.results if level == "CRITICAL")
        warnings = sum(1 for level, _ in self.results if level == "WARNING")
        passed = sum(1 for level, _ in self.results if level == "PASS")
        
        print(f"\nüìä SUMMARY:")
        print(f"   ‚õî CRITICAL Issues: {critical}")
        print(f"   ‚ö†Ô∏è  Warnings: {warnings}")
        print(f"   ‚úÖ Passed: {passed}")
        
        return len([1 for level, _ in self.results if level == "CRITICAL"]) == 0

if __name__ == "__main__":
    pentest = DemoServerPentest(BASE_URL)
    success = pentest.run_all_tests()
    sys.exit(0 if success else 1)
